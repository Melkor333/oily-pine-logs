pigz: not found
>>> py3-cffi: Building main/py3-cffi 1.17.1-r1 (using abuild 3.14.1-r4) started Fri, 23 May 2025 16:34:22 +0000
>>> py3-cffi: Validating /home/packager/aports/main/py3-cffi/APKBUILD...
>>> py3-cffi: Analyzing dependencies...
>>> py3-cffi: Installing for build: build-base py3-cparser libffi-dev python3-dev py3-gpep517 py3-setuptools py3-wheel py3-pytest
(1/34) Installing libffi (3.4.7-r0)
(2/34) Installing gdbm (1.24-r0)
(3/34) Installing xz-libs (5.6.3-r1)
(4/34) Installing mpdecimal (4.0.0-r0)
(5/34) Installing sqlite-libs (3.49.2-r0)
(6/34) Installing python3 (3.12.10-r1)
(7/34) Installing python3-pycache-pyc0 (3.12.10-r1)
(8/34) Installing pyc (3.12.10-r1)
(9/34) Installing py3-cparser-pyc (2.22-r1)
(10/34) Installing python3-pyc (3.12.10-r1)
(11/34) Installing py3-cparser (2.22-r1)
(12/34) Installing libffi-dev (3.4.7-r0)
(13/34) Installing python3-dev (3.12.10-r1)
(14/34) Installing py3-installer (0.7.0-r2)
(15/34) Installing py3-installer-pyc (0.7.0-r2)
(16/34) Installing py3-gpep517 (19-r0)
(17/34) Installing py3-gpep517-pyc (19-r0)
(18/34) Installing py3-parsing (3.2.3-r0)
(19/34) Installing py3-parsing-pyc (3.2.3-r0)
(20/34) Installing py3-packaging (25.0-r0)
(21/34) Installing py3-packaging-pyc (25.0-r0)
(22/34) Installing py3-setuptools (80.3.1-r0)
(23/34) Installing py3-setuptools-pyc (80.3.1-r0)
(24/34) Installing py3-wheel (0.46.1-r0)
(25/34) Installing py3-wheel-pyc (0.46.1-r0)
(26/34) Installing py3-iniconfig (2.1.0-r0)
(27/34) Installing py3-iniconfig-pyc (2.1.0-r0)
(28/34) Installing py3-pluggy (1.5.0-r0)
(29/34) Installing py3-pluggy-pyc (1.5.0-r0)
(30/34) Installing py3-py (1.11.0-r4)
(31/34) Installing py3-py-pyc (1.11.0-r4)
(32/34) Installing py3-pytest (8.3.5-r0)
(33/34) Installing py3-pytest-pyc (8.3.5-r0)
(34/34) Installing .makedepends-py3-cffi (20250523.163424)
Executing busybox-1.37.0-r12.trigger
OK: 706 MiB in 166 packages
>>> py3-cffi: Cleaning up srcdir
>>> py3-cffi: Cleaning up pkgdir
>>> py3-cffi: Cleaning up tmpdir
>>> py3-cffi: Fetching https://files.pythonhosted.org/packages/source/c/cffi/cffi-1.17.1.tar.gz
Connecting to files.pythonhosted.org (151.101.64.223:443)
Connecting to files.pythonhosted.org (151.101.0.223:443)
saving to '/var/cache/distfiles/cffi-1.17.1.tar.gz.part'
cffi-1.17.1.tar.gz.p 100% |********************************|  504k  0:00:00 ETA
'/var/cache/distfiles/cffi-1.17.1.tar.gz.part' saved
>>> py3-cffi: Fetching https://files.pythonhosted.org/packages/source/c/cffi/cffi-1.17.1.tar.gz
>>> py3-cffi: Checking sha512sums...
cffi-1.17.1.tar.gz: OK
fix-setuptools-deprecation.patch: OK
>>> py3-cffi: Unpacking /var/cache/distfiles/cffi-1.17.1.tar.gz...
>>> py3-cffi: fix-setuptools-deprecation.patch
patching file setup.cfg
2025-05-23 16:34:28,373 gpep517 INFO Building wheel via backend setuptools.build_meta
2025-05-23 16:34:28,436 root INFO compiling '_configtest.c':
2025-05-23 16:34:28,436 root INFO __thread int some_threadlocal_variable_42;

2025-05-23 16:34:28,437 root INFO gcc -Os -fstack-clash-protection -Wformat -Werror=format-security -fno-plt -fPIC -c _configtest.c -o _configtest.o
2025-05-23 16:34:28,488 root INFO success!
2025-05-23 16:34:28,488 root INFO removing: _configtest.c _configtest.o
2025-05-23 16:34:28,511 root INFO compiling '_configtest.c':
2025-05-23 16:34:28,511 root INFO int main(void) { __sync_synchronize(); return 0; }

2025-05-23 16:34:28,512 root INFO gcc -Os -fstack-clash-protection -Wformat -Werror=format-security -fno-plt -fPIC -c _configtest.c -o _configtest.o
2025-05-23 16:34:28,557 root INFO gcc _configtest.o -o _configtest
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: _configtest: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: _configtest has a LOAD segment with RWX permissions
collect2: error: ld returned 1 exit status
2025-05-23 16:34:28,573 root INFO failure.
2025-05-23 16:34:28,573 root INFO removing: _configtest.c _configtest.o
Note: will not use '__sync_synchronize()' in the C code
***** The above error message can be safely ignored.

/usr/lib/python3.12/site-packages/setuptools/dist.py:761: SetuptoolsDeprecationWarning: License classifiers are deprecated.
!!

        ********************************************************************************
        Please consider removing the following classifiers in favor of a SPDX license expression:

        License :: OSI Approved :: MIT License

        See https://packaging.python.org/en/latest/guides/writing-pyproject-toml/#license for details.
        ********************************************************************************

!!
  self._finalize_license_expression()
2025-05-23 16:34:28,613 root INFO running bdist_wheel
2025-05-23 16:34:28,643 root INFO running build
2025-05-23 16:34:28,643 root INFO running build_py
2025-05-23 16:34:28,651 root INFO creating build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,651 root INFO copying src/cffi/commontypes.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,652 root INFO copying src/cffi/_shimmed_dist_utils.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,652 root INFO copying src/cffi/recompiler.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,653 root INFO copying src/cffi/_imp_emulation.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,653 root INFO copying src/cffi/model.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,655 root INFO copying src/cffi/cffi_opcode.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,655 root INFO copying src/cffi/ffiplatform.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,656 root INFO copying src/cffi/pkgconfig.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,657 root INFO copying src/cffi/backend_ctypes.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,657 root INFO copying src/cffi/vengine_cpy.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,658 root INFO copying src/cffi/__init__.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,658 root INFO copying src/cffi/api.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,659 root INFO copying src/cffi/vengine_gen.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,659 root INFO copying src/cffi/error.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,660 root INFO copying src/cffi/setuptools_ext.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,660 root INFO copying src/cffi/verifier.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,661 root INFO copying src/cffi/cparser.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,661 root INFO copying src/cffi/lock.py -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,662 root INFO copying src/cffi/_cffi_include.h -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,663 root INFO copying src/cffi/parse_c_type.h -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,663 root INFO copying src/cffi/_embedding.h -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,664 root INFO copying src/cffi/_cffi_errors.h -> build/lib.linux-x86_64-cpython-312/cffi
2025-05-23 16:34:28,664 root INFO running build_ext
2025-05-23 16:34:28,666 root INFO building '_cffi_backend' extension
2025-05-23 16:34:28,666 root INFO creating build/temp.linux-x86_64-cpython-312/src/c
2025-05-23 16:34:28,667 root INFO gcc -Os -fstack-clash-protection -Wformat -Werror=format-security -fno-plt -fPIC -DFFI_BUILDING=1 -DUSE__THREAD -I/usr/include/python3.12 -c src/c/_cffi_backend.c -o build/temp.linux-x86_64-cpython-312/src/c/_cffi_backend.o
src/c/_cffi_backend.c: In function 'b_do_dlopen':
src/c/_cffi_backend.c:4579:22: warning: 'Py_FileSystemDefaultEncoding' is deprecated [-Wdeprecated-declarations]
 4579 |                      Py_FileSystemDefaultEncoding, &filename_or_null, &flags))
      |                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/python3.12/Python.h:72,
                 from src/c/_cffi_backend.c:2:
/usr/include/python3.12/fileobject.h:22:46: note: declared here
   22 | Py_DEPRECATED(3.12) PyAPI_DATA(const char *) Py_FileSystemDefaultEncoding;
      |                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
2025-05-23 16:34:36,523 root INFO gcc -shared -Wl,--as-needed,-O1,--sort-common -Wl,-z,pack-relative-relocs -Os -fstack-clash-protection -Wformat -Werror=format-security -fno-plt build/temp.linux-x86_64-cpython-312/src/c/_cffi_backend.o -L/usr/lib/../lib -L/usr/lib -lffi -o build/lib.linux-x86_64-cpython-312/_cffi_backend.cpython-312-x86_64-linux-musl.so
2025-05-23 16:34:36,586 root INFO installing to build/bdist.linux-x86_64/wheel
2025-05-23 16:34:36,586 root INFO running install
2025-05-23 16:34:36,608 root INFO running install_lib
2025-05-23 16:34:36,615 root INFO creating build/bdist.linux-x86_64/wheel
2025-05-23 16:34:36,616 root INFO copying build/lib.linux-x86_64-cpython-312/_cffi_backend.cpython-312-x86_64-linux-musl.so -> build/bdist.linux-x86_64/wheel/.
2025-05-23 16:34:36,616 root INFO creating build/bdist.linux-x86_64/wheel/cffi
2025-05-23 16:34:36,617 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/commontypes.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,617 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/_shimmed_dist_utils.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,617 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/recompiler.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,618 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/_imp_emulation.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,618 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/model.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,618 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/cffi_opcode.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,619 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/ffiplatform.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,619 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/pkgconfig.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,619 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/backend_ctypes.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,620 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/vengine_cpy.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,620 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/__init__.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,621 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/api.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,621 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/vengine_gen.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,621 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/_embedding.h -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,622 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/error.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,622 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/_cffi_include.h -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,622 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/setuptools_ext.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,623 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/parse_c_type.h -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,623 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/verifier.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,623 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/_cffi_errors.h -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,624 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/cparser.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,624 root INFO copying build/lib.linux-x86_64-cpython-312/cffi/lock.py -> build/bdist.linux-x86_64/wheel/./cffi
2025-05-23 16:34:36,624 root INFO running install_egg_info
2025-05-23 16:34:36,632 root INFO running egg_info
2025-05-23 16:34:36,637 root INFO writing src/cffi.egg-info/PKG-INFO
2025-05-23 16:34:36,658 root INFO writing dependency_links to src/cffi.egg-info/dependency_links.txt
2025-05-23 16:34:36,710 root INFO writing entry points to src/cffi.egg-info/entry_points.txt
2025-05-23 16:34:36,711 root INFO writing requirements to src/cffi.egg-info/requires.txt
2025-05-23 16:34:36,711 root INFO writing top-level names to src/cffi.egg-info/top_level.txt
2025-05-23 16:34:36,720 root INFO reading manifest file 'src/cffi.egg-info/SOURCES.txt'
2025-05-23 16:34:36,727 root INFO reading manifest template 'MANIFEST.in'
2025-05-23 16:34:36,759 root INFO adding license file 'LICENSE'
2025-05-23 16:34:36,766 root INFO writing manifest file 'src/cffi.egg-info/SOURCES.txt'
2025-05-23 16:34:36,767 root INFO Copying src/cffi.egg-info to build/bdist.linux-x86_64/wheel/./cffi-1.17.1-py3.12.egg-info
2025-05-23 16:34:36,769 root INFO running install_scripts
2025-05-23 16:34:36,778 root INFO creating build/bdist.linux-x86_64/wheel/cffi-1.17.1.dist-info/WHEEL
2025-05-23 16:34:36,779 wheel INFO creating '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.dist/.tmp-t5wjdw9o/cffi-1.17.1-cp312-cp312-linux_x86_64.whl' and adding 'build/bdist.linux-x86_64/wheel' to it
2025-05-23 16:34:36,780 wheel INFO adding '_cffi_backend.cpython-312-x86_64-linux-musl.so'
2025-05-23 16:34:36,781 wheel INFO adding 'cffi/__init__.py'
2025-05-23 16:34:36,782 wheel INFO adding 'cffi/_cffi_errors.h'
2025-05-23 16:34:36,782 wheel INFO adding 'cffi/_cffi_include.h'
2025-05-23 16:34:36,783 wheel INFO adding 'cffi/_embedding.h'
2025-05-23 16:34:36,783 wheel INFO adding 'cffi/_imp_emulation.py'
2025-05-23 16:34:36,784 wheel INFO adding 'cffi/_shimmed_dist_utils.py'
2025-05-23 16:34:36,787 wheel INFO adding 'cffi/api.py'
2025-05-23 16:34:36,787 wheel INFO adding 'cffi/backend_ctypes.py'
2025-05-23 16:34:36,788 wheel INFO adding 'cffi/cffi_opcode.py'
2025-05-23 16:34:36,788 wheel INFO adding 'cffi/commontypes.py'
2025-05-23 16:34:36,789 wheel INFO adding 'cffi/cparser.py'
2025-05-23 16:34:36,790 wheel INFO adding 'cffi/error.py'
2025-05-23 16:34:36,790 wheel INFO adding 'cffi/ffiplatform.py'
2025-05-23 16:34:36,790 wheel INFO adding 'cffi/lock.py'
2025-05-23 16:34:36,791 wheel INFO adding 'cffi/model.py'
2025-05-23 16:34:36,791 wheel INFO adding 'cffi/parse_c_type.h'
2025-05-23 16:34:36,792 wheel INFO adding 'cffi/pkgconfig.py'
2025-05-23 16:34:36,792 wheel INFO adding 'cffi/recompiler.py'
2025-05-23 16:34:36,793 wheel INFO adding 'cffi/setuptools_ext.py'
2025-05-23 16:34:36,794 wheel INFO adding 'cffi/vengine_cpy.py'
2025-05-23 16:34:36,794 wheel INFO adding 'cffi/vengine_gen.py'
2025-05-23 16:34:36,795 wheel INFO adding 'cffi/verifier.py'
2025-05-23 16:34:36,796 wheel INFO adding 'cffi-1.17.1.dist-info/licenses/LICENSE'
2025-05-23 16:34:36,796 wheel INFO adding 'cffi-1.17.1.dist-info/METADATA'
2025-05-23 16:34:36,796 wheel INFO adding 'cffi-1.17.1.dist-info/WHEEL'
2025-05-23 16:34:36,797 wheel INFO adding 'cffi-1.17.1.dist-info/entry_points.txt'
2025-05-23 16:34:36,797 wheel INFO adding 'cffi-1.17.1.dist-info/top_level.txt'
2025-05-23 16:34:36,797 wheel INFO adding 'cffi-1.17.1.dist-info/RECORD'
2025-05-23 16:34:36,798 root INFO removing build/bdist.linux-x86_64/wheel
2025-05-23 16:34:36,800 gpep517 INFO The backend produced .dist/cffi-1.17.1-cp312-cp312-linux_x86_64.whl
cffi-1.17.1-cp312-cp312-linux_x86_64.whl
============================= test session starts ==============================
platform linux -- Python 3.12.10, pytest-8.3.5, pluggy-1.5.0
rootdir: /home/packager/aports/main/py3-cffi/src/cffi-1.17.1
configfile: pyproject.toml
collected 1824 items

testing/cffi0/test_cdata.py .                                            [  0%]
testing/cffi0/test_ctypes.py ..................s...............s.s.s.... [  2%]
...s.........................sssssss..s..s.............................. [  6%]
...............sssssssss                                                 [  7%]
testing/cffi0/test_ffi_backend.py ..........s.......s.........s......... [  9%]
..ss.................................................................... [ 13%]
...................s...s................................................ [ 17%]
.................s.s...s...................                              [ 20%]
testing/cffi0/test_function.py ......s.......s.s...s..ss..sss..ss        [ 21%]
testing/cffi0/test_model.py .............                                [ 22%]
testing/cffi0/test_ownlib.py ..ss...sssss                                [ 23%]
testing/cffi0/test_parsing.py .........................s...........      [ 25%]
testing/cffi0/test_platform.py ....                                      [ 25%]
testing/cffi0/test_unicode_literals.py ............                      [ 26%]
testing/cffi0/test_verify.py ...................s......s.....s.......... [ 28%]
........................................................................ [ 32%]
....s..........................s...s.............ss..                    [ 35%]
testing/cffi0/test_verify2.py ...................s......s.....s......... [ 37%]
........................................................................ [ 41%]
.....s..........................s...s.............ss..                   [ 44%]
testing/cffi0/test_version.py .....                                      [ 44%]
testing/cffi0/test_vgen.py ...................s......s.....s............ [ 47%]
........................................................................ [ 51%]
..s..........................s...s.............ss..                      [ 54%]
testing/cffi0/test_vgen2.py ...................s......s.....s........... [ 56%]
........................................................................ [ 60%]
...s..........................s...s.............ss..                     [ 63%]
testing/cffi0/test_zdistutils.py ......................................  [ 65%]
testing/cffi0/test_zintegration.py sssssss.                              [ 65%]
testing/cffi1/test_cffi_binary.py s                                      [ 65%]
testing/cffi1/test_commontypes.py ss.                                    [ 66%]
testing/cffi1/test_dlopen.py ...............                             [ 66%]
testing/cffi1/test_dlopen_unicode_literals.py ...............            [ 67%]
testing/cffi1/test_ffi_obj.py .............................s............ [ 69%]
.                                                                        [ 70%]
testing/cffi1/test_function_args.py s                                    [ 70%]
testing/cffi1/test_new_ffi_1.py ........................................ [ 72%]
.........................................s...s.......................... [ 76%]
............                                                             [ 76%]
testing/cffi1/test_parse_c_type.py ..................                    [ 77%]
testing/cffi1/test_pkgconfig.py ...                                      [ 78%]
testing/cffi1/test_re_python.py ....................s                    [ 79%]
testing/cffi1/test_realize_c_type.py .........                           [ 79%]
testing/cffi1/test_recompiler.py ....................................... [ 81%]
..........................s............................................. [ 85%]
.......................s.....s..........................                 [ 88%]
testing/cffi1/test_unicode_literals.py .......                           [ 89%]
testing/cffi1/test_verify1.py ..............................s........... [ 91%]
...............................................................s.....xxx [ 95%]
s...x......................s...s....s...s.ss                             [ 97%]
testing/cffi1/test_zdist.py .......................                      [ 99%]
testing/embedding/test_basic.py FFFFF                                    [ 99%]
testing/embedding/test_performance.py FFFFF                              [ 99%]
testing/embedding/test_recursive.py F                                    [ 99%]
testing/embedding/test_thread.py FFFF                                    [ 99%]
testing/embedding/test_tlocal.py F                                       [100%]

=================================== FAILURES ===================================
_____________________________ TestBasic.test_empty _____________________________

cmd = ['/usr/bin/cc', 'empty-test.o', '/tmp/ffi-0/embedding/test_empty/_empty_cffi.so', '-o', 'empty-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', 'empty-test.o', '/tmp/ffi-0/embedding/test_empty/_empty_cffi.so', '-o', 'empty-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', 'empty-test.o', '/tmp/ffi-0/embedding/test_empty/_empty_cffi.so', '-o', 'empty-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', 'empty-test.o', '/tmp/ffi-0/embedding/test_empty/_empty_cffi.so', '-o', 'empty-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd9187f50>
target_desc = 'executable'
objects = ['empty-test.o', '/tmp/ffi-0/embedding/test_empty/_empty_cffi.so']
output_filename = 'empty-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', 'empty-test.o', '/tmp/ffi-0/embedding/test_empty/_empty_cffi.so', '-o', 'empty-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_basic.TestBasic object at 0x7f9bd9ec53d0>

    def test_empty(self):
        empty_cffi = self.prepare_module('empty')
>       self.compile('empty-test', [empty_cffi])

testing/embedding/test_basic.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd9187f50>
target_desc = 'executable'
objects = ['empty-test.o', '/tmp/ffi-0/embedding/test_empty/_empty_cffi.so']
output_filename = 'empty-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
---------------------------- Captured stdout setup -----------------------------
generating /tmp/ffi-0/embedding/_test_lib_python_found.c
setting the current directory to '/tmp/ffi-0/embedding'
---------------------------- Captured stderr setup -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_test_lib_python_found.cpython-312-x86_64-linux-musl.so has a LOAD segment with RWX permissions
------------------------------ Captured log setup ------------------------------
INFO     root:dist.py:1018 running build_ext
INFO     root:build_ext.py:538 building '_test_lib_python_found' extension
INFO     root:spawn.py:77 gcc -Os -fstack-clash-protection -Wformat -Werror=format-security -fno-plt -fPIC -I/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/include -I/usr/include/python3.12 -c _test_lib_python_found.c -o ./_test_lib_python_found.o
INFO     root:spawn.py:77 gcc -shared -Wl,--as-needed,-O1,--sort-common -Wl,-z,pack-relative-relocs -Os -fstack-clash-protection -Wformat -Werror=format-security -fno-plt ./_test_lib_python_found.o -L/usr/lib -lpython3.12 -o ./_test_lib_python_found.cpython-312-x86_64-linux-musl.so
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_empty'
* setting env var 'PYTHONPATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1:/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/build/lib.linux-x86_64-cpython-312'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_empty/empty.py'] {'cwd': '/tmp/ffi-0/embedding/test_empty', 'stdout': -1, 'universal_newlines': True}
generating ./_empty_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_empty'
FILENAME: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so
compiling empty-test with ['/tmp/ffi-0/embedding/test_empty/_empty_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_empty_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_empty/_empty_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: empty-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: empty-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_empty/_empty_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
_____________________________ TestBasic.test_basic _____________________________

cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'add1-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'add1-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'add1-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'add1-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd8be02c0>
target_desc = 'executable'
objects = ['add1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so']
output_filename = 'add1-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'add1-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_basic.TestBasic object at 0x7f9bd9df9e50>

    def test_basic(self):
        add1_cffi = self.prepare_module('add1')
>       self.compile('add1-test', [add1_cffi])

testing/embedding/test_basic.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd8be02c0>
target_desc = 'executable'
objects = ['add1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so']
output_filename = 'add1-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_basic'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_basic/add1.py'] {'cwd': '/tmp/ffi-0/embedding/test_basic', 'stdout': -1, 'universal_newlines': True}
generating ./_add1_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_basic'
FILENAME: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so
compiling add1-test with ['/tmp/ffi-0/embedding/test_basic/_add1_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_add1_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_basic/_add1_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: add1-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: add1-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
__________________________ TestBasic.test_two_modules __________________________

cmd = ['/usr/bin/cc', 'add2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', 'add2-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', 'add2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', 'add2-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', 'add2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', 'add2-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', 'add2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', 'add2-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd9f840b0>
target_desc = 'executable'
objects = ['add2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
output_filename = 'add2-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', 'add2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', 'add2-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_basic.TestBasic object at 0x7f9bd9df8da0>

    def test_two_modules(self):
        add1_cffi = self.prepare_module('add1')
        add2_cffi = self.prepare_module('add2')
>       self.compile('add2-test', [add1_cffi, add2_cffi])

testing/embedding/test_basic.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd9f840b0>
target_desc = 'executable'
objects = ['add2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
output_filename = 'add2-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_two_modules'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_two_modules/add2.py'] {'cwd': '/tmp/ffi-0/embedding/test_two_modules', 'stdout': -1, 'universal_newlines': True}
generating ./_add2_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_two_modules'
FILENAME: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so
compiling add2-test with ['/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_add2_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_basic/_add1_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: add2-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: add2-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
________________________ TestBasic.test_init_time_error ________________________

cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so', '-o', 'add1-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so', '-o', 'add1-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so', '-o', 'add1-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so', '-o', 'add1-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd9ec3d70>
target_desc = 'executable'
objects = ['add1-test.o', '/tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so']
output_filename = 'add1-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so', '-o', 'add1-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_basic.TestBasic object at 0x7f9bd9df9190>

    def test_init_time_error(self):
        initerror_cffi = self.prepare_module('initerror')
>       self.compile('add1-test', [initerror_cffi])

testing/embedding/test_basic.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd9ec3d70>
target_desc = 'executable'
objects = ['add1-test.o', '/tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so']
output_filename = 'add1-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_init_time_error'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_init_time_error/initerror.py'] {'cwd': '/tmp/ffi-0/embedding/test_init_time_error', 'stdout': -1, 'universal_newlines': True}
generating ./_initerror_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_init_time_error'
FILENAME: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so
compiling add1-test with ['/tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_initerror_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: add1-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: add1-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_init_time_error/_initerror_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
____________________ TestBasic.test_embedding_with_unicode _____________________

cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so', '-o', 'add1-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so', '-o', 'add1-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so', '-o', 'add1-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so', '-o', 'add1-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96c61e0>
target_desc = 'executable'
objects = ['add1-test.o', '/tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so']
output_filename = 'add1-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', 'add1-test.o', '/tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so', '-o', 'add1-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_basic.TestBasic object at 0x7f9bd9df92b0>

    def test_embedding_with_unicode(self):
        withunicode_cffi = self.prepare_module('withunicode')
>       self.compile('add1-test', [withunicode_cffi])

testing/embedding/test_basic.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96c61e0>
target_desc = 'executable'
objects = ['add1-test.o', '/tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so']
output_filename = 'add1-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_embedding_with_unicode'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_embedding_with_unicode/withunicode.py'] {'cwd': '/tmp/ffi-0/embedding/test_embedding_with_unicode', 'stdout': -1, 'universal_newlines': True}
generating ./_withunicode_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_embedding_with_unicode'
FILENAME: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so
compiling add1-test with ['/tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_withunicode_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: add1-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: add1-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_embedding_with_unicode/_withunicode_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
__________________ TestPerformance.test_perf_single_threaded ___________________

cmd = ['/usr/bin/cc', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96c4c50>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_performance.TestPerformance object at 0x7f9bd9df9100>

    def test_perf_single_threaded(self):
        perf_cffi = self.prepare_module('perf')
>       self.compile('perf-test', [perf_cffi], opt=True)

testing/embedding/test_performance.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96c4c50>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_perf_single_threaded'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_perf_single_threaded/perf.py'] {'cwd': '/tmp/ffi-0/embedding/test_perf_single_threaded', 'stdout': -1, 'universal_newlines': True}
generating ./_perf_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_perf_single_threaded'
FILENAME: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so
compiling perf-test with ['/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_perf_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: perf-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: perf-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
____________________ TestPerformance.test_perf_in_1_thread _____________________

cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd9ec5a00>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_performance.TestPerformance object at 0x7f9bd9df8e60>

    def test_perf_in_1_thread(self):
        perf_cffi = self.prepare_module('perf')
>       self.compile('perf-test', [perf_cffi], opt=True, threads=True,
                     defines={'PTEST_USE_THREAD': '1'})

testing/embedding/test_performance.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd9ec5a00>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_perf_in_1_thread'
compiling perf-test with ['/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: perf-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: perf-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
____________________ TestPerformance.test_perf_in_2_threads ____________________

cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96c60f0>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_performance.TestPerformance object at 0x7f9bd9df96d0>

    def test_perf_in_2_threads(self):
        perf_cffi = self.prepare_module('perf')
>       self.compile('perf-test', [perf_cffi], opt=True, threads=True,
                     defines={'PTEST_USE_THREAD': '2'})

testing/embedding/test_performance.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96c60f0>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_perf_in_2_threads'
compiling perf-test with ['/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: perf-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: perf-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
____________________ TestPerformance.test_perf_in_4_threads ____________________

cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd975dfa0>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_performance.TestPerformance object at 0x7f9bd9dfa630>

    def test_perf_in_4_threads(self):
        perf_cffi = self.prepare_module('perf')
>       self.compile('perf-test', [perf_cffi], opt=True, threads=True,
                     defines={'PTEST_USE_THREAD': '4'})

testing/embedding/test_performance.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd975dfa0>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_perf_in_4_threads'
compiling perf-test with ['/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: perf-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: perf-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
____________________ TestPerformance.test_perf_in_8_threads ____________________

cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd975d190>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so', '-o', 'perf-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_performance.TestPerformance object at 0x7f9bd9dfa1b0>

    def test_perf_in_8_threads(self):
        perf_cffi = self.prepare_module('perf')
>       self.compile('perf-test', [perf_cffi], opt=True, threads=True,
                     defines={'PTEST_USE_THREAD': '8'})

testing/embedding/test_performance.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd975d190>
target_desc = 'executable'
objects = ['perf-test.o', '/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
output_filename = 'perf-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_perf_in_8_threads'
compiling perf-test with ['/tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: perf-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: perf-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_perf_single_threaded/_perf_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
_________________________ TestRecursive.test_recursive _________________________

cmd = ['/usr/bin/cc', 'add_recursive-test.o', '/tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so', '-o', 'add_recursive-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', 'add_recursive-test.o', '/tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so', '-o', 'add_recursive-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', 'add_recursive-test.o', '/tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so', '-o', 'add_recursive-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', 'add_recursive-test.o', '/tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so', '-o', 'add_recursive-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd975f710>
target_desc = 'executable'
objects = ['add_recursive-test.o', '/tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so']
output_filename = 'add_recursive-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', 'add_recursive-test.o', '/tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so', '-o', 'add_recursive-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_recursive.TestRecursive object at 0x7f9bd9df9b50>

    def test_recursive(self):
        add_recursive_cffi = self.prepare_module('add_recursive')
>       self.compile('add_recursive-test', [add_recursive_cffi])

testing/embedding/test_recursive.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd975f710>
target_desc = 'executable'
objects = ['add_recursive-test.o', '/tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so']
output_filename = 'add_recursive-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = [], extra_postargs = None, build_temp = None
target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_recursive'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_recursive/add_recursive.py'] {'cwd': '/tmp/ffi-0/embedding/test_recursive', 'stdout': -1, 'universal_newlines': True}
generating ./_add_recursive_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_recursive'
FILENAME: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so
compiling add_recursive-test with ['/tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_add_recursive_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: add_recursive-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: add_recursive-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_recursive/_add_recursive_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
___________________ TestThread.test_first_calls_in_parallel ____________________

cmd = ['/usr/bin/cc', '-pthread', 'thread1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'thread1-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'thread1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'thread1-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'thread1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'thread1-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'thread1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'thread1-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bda27fce0>
target_desc = 'executable'
objects = ['thread1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so']
output_filename = 'thread1-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'thread1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '-o', 'thread1-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_thread.TestThread object at 0x7f9bd9dfb500>

    def test_first_calls_in_parallel(self):
        add1_cffi = self.prepare_module('add1')
>       self.compile('thread1-test', [add1_cffi], threads=True)

testing/embedding/test_thread.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bda27fce0>
target_desc = 'executable'
objects = ['thread1-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so']
output_filename = 'thread1-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_first_calls_in_parallel'
compiling thread1-test with ['/tmp/ffi-0/embedding/test_basic/_add1_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_basic/_add1_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: thread1-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: thread1-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
_________ TestThread.test_init_different_modules_in_different_threads __________

cmd = ['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', ...]
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', ...],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', ...]

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', 'thread2-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96a3ec0>
target_desc = 'executable'
objects = ['thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
output_filename = 'thread2-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', ...]
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_thread.TestThread object at 0x7f9bd9df99d0>

    def test_init_different_modules_in_different_threads(self):
        add1_cffi = self.prepare_module('add1')
        add2_cffi = self.prepare_module('add2')
>       self.compile('thread2-test', [add1_cffi, add2_cffi], threads=True)

testing/embedding/test_thread.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96a3ec0>
target_desc = 'executable'
objects = ['thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
output_filename = 'thread2-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_init_different_modules_in_different_threads'
compiling thread2-test with ['/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_basic/_add1_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: thread2-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: thread2-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
__________________________ TestThread.test_alt_issue ___________________________

cmd = ['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', ...]
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', ...],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', ...]

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', 'thread2-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96a3530>
target_desc = 'executable'
objects = ['thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
output_filename = 'thread2-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '-o', ...]
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_thread.TestThread object at 0x7f9bd9dfa0f0>

    def test_alt_issue(self):
        add1_cffi = self.prepare_module('add1')
        add2_cffi = self.prepare_module('add2')
>       self.compile('thread2-test', [add1_cffi, add2_cffi],
                     threads=True, defines={'T2TEST_AGAIN_ADD1': '1'})

testing/embedding/test_thread.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd96a3530>
target_desc = 'executable'
objects = ['thread2-test.o', '/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
output_filename = 'thread2-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_alt_issue'
compiling thread2-test with ['/tmp/ffi-0/embedding/test_basic/_add1_cffi.so', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_basic/_add1_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: thread2-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: thread2-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_basic/_add1_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
____________________ TestThread.test_load_in_parallel_more _____________________

cmd = ['/usr/bin/cc', '-pthread', 'thread3-test.o', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '/tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so', '-o', ...]
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'thread3-test.o', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '/tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so', '-o', ...],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'thread3-test.o', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '/tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so', '-o', ...]

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'thread3-test.o', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '/tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so', '-o', 'thread3-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bda1319a0>
target_desc = 'executable'
objects = ['thread3-test.o', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '/tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so']
output_filename = 'thread3-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'thread3-test.o', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '/tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so', '-o', ...]
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_thread.TestThread object at 0x7f9bd9dfa2a0>

    def test_load_in_parallel_more(self):
        add2_cffi = self.prepare_module('add2')
        add3_cffi = self.prepare_module('add3')
>       self.compile('thread3-test', [add2_cffi, add3_cffi], threads=True)

testing/embedding/test_thread.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bda1319a0>
target_desc = 'executable'
objects = ['thread3-test.o', '/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '/tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so']
output_filename = 'thread3-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_load_in_parallel_more'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_load_in_parallel_more/add3.py'] {'cwd': '/tmp/ffi-0/embedding/test_load_in_parallel_more', 'stdout': -1, 'universal_newlines': True}
generating ./_add3_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_load_in_parallel_more'
FILENAME: /tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so
compiling thread3-test with ['/tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so', '/tmp/ffi-0/embedding/test_load_in_parallel_more/_add3_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_add3_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: thread3-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: thread3-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_two_modules/_add2_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
______________________ TestThreadLocal.test_thread_local _______________________

cmd = ['/usr/bin/cc', '-pthread', 'tlocal-test.o', '/tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so', '-o', 'tlocal-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
>           subprocess.check_call(cmd, env=_inject_macos_ver(env))

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

popenargs = (['/usr/bin/cc', '-pthread', 'tlocal-test.o', '/tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so', '-o', 'tlocal-test'],)
kwargs = {'env': None}, retcode = 1
cmd = ['/usr/bin/cc', '-pthread', 'tlocal-test.o', '/tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so', '-o', 'tlocal-test']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.
    
        The arguments are the same as for the call function.  Example:
    
        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', 'tlocal-test.o', '/tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so', '-o', 'tlocal-test']' returned non-zero exit status 1.

/usr/lib/python3.12/subprocess.py:413: CalledProcessError

The above exception was the direct cause of the following exception:

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd7590140>
target_desc = 'executable'
objects = ['tlocal-test.o', '/tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so']
output_filename = 'tlocal-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
>               self.spawn(linker + ld_args)

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:1158: in spawn
    spawn(cmd, dry_run=self.dry_run, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['/usr/bin/cc', '-pthread', 'tlocal-test.o', '/tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so', '-o', 'tlocal-test']
search_path = True, verbose = False, dry_run = False, env = None

    def spawn(
        cmd: MutableSequence[bytes | str | os.PathLike[str]],
        search_path: bool = True,
        verbose: bool = False,
        dry_run: bool = False,
        env: _ENV | None = None,
    ) -> None:
        """Run another program, specified as a command list 'cmd', in a new process.
    
        'cmd' is just the argument list for the new process, ie.
        cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
        There is no way to run a program with a name different from that of its
        executable.
    
        If 'search_path' is true (the default), the system's executable
        search path will be used to find the program; otherwise, cmd[0]
        must be the exact path to the executable.  If 'dry_run' is true,
        the command will not actually be run.
    
        Raise DistutilsExecError if running the program fails in any way; just
        return on success.
        """
        log.info(subprocess.list2cmdline(cmd))
        if dry_run:
            return
    
        if search_path:
            executable = shutil.which(cmd[0])
            if executable is not None:
                cmd[0] = executable
    
        try:
            subprocess.check_call(cmd, env=_inject_macos_ver(env))
        except OSError as exc:
            raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed: {exc.args[-1]}"
            ) from exc
        except subprocess.CalledProcessError as err:
>           raise DistutilsExecError(
                f"command {_debug(cmd)!r} failed with exit code {err.returncode}"
            ) from err
E           distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/spawn.py:93: DistutilsExecError

During handling of the above exception, another exception occurred:

self = <testing.embedding.test_tlocal.TestThreadLocal object at 0x7f9bd9dfb260>

    def test_thread_local(self):
        tlocal_cffi = self.prepare_module('tlocal')
>       self.compile('tlocal-test', [tlocal_cffi], threads=True)

testing/embedding/test_tlocal.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
testing/embedding/test_basic.py:136: in compile
    c.link_executable(objects + modules, name, extra_preargs=extra_preargs)
/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/base.py:841: in link_executable
    self.link(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <distutils.compilers.C.unix.Compiler object at 0x7f9bd7590140>
target_desc = 'executable'
objects = ['tlocal-test.o', '/tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so']
output_filename = 'tlocal-test', output_dir = None, libraries = []
library_dirs = [], runtime_library_dirs = [], export_symbols = None
debug = False, extra_preargs = ['-pthread'], extra_postargs = None
build_temp = None, target_lang = None

    def link(
        self,
        target_desc,
        objects: list[str] | tuple[str, ...],
        output_filename,
        output_dir: str | None = None,
        libraries: list[str] | tuple[str, ...] | None = None,
        library_dirs: list[str] | tuple[str, ...] | None = None,
        runtime_library_dirs: list[str] | tuple[str, ...] | None = None,
        export_symbols=None,
        debug=False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        libraries, library_dirs, runtime_library_dirs = fixed_args
    
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
        if not isinstance(output_dir, (str, type(None))):
            raise TypeError("'output_dir' must be a string or None")
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)
    
        if self._need_link(objects, output_filename):
            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                # Select a linker based on context: linker_exe when
                # building an executable or linker_so (with shared options)
                # when building a shared library.
                building_exe = target_desc == base.Compiler.EXECUTABLE
                target_cxx = target_lang == "c++"
                linker = (
                    (self.linker_exe_cxx if target_cxx else self.linker_exe)
                    if building_exe
                    else (self.linker_so_cxx if target_cxx else self.linker_so)
                )[:]
    
                if target_cxx and self.compiler_cxx:
                    env, linker_ne = _split_env(linker)
                    aix, linker_na = _split_aix(linker_ne)
                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)
                    _, linker_exe_ne = _split_env(self.linker_exe_cxx)
    
                    params = _linker_params(linker_na, linker_exe_ne)
                    linker = env + aix + compiler_cxx_ne + params
    
                linker = compiler_fixup(linker, ld_args)
    
                self.spawn(linker + ld_args)
            except DistutilsExecError as msg:
>               raise LinkError(msg)
E               distutils.compilers.C.errors.LinkError: command '/usr/bin/cc' failed with exit code 1

/usr/lib/python3.12/site-packages/setuptools/_distutils/compilers/C/unix.py:309: LinkError
----------------------------- Captured stdout call -----------------------------
* setting env var 'LD_LIBRARY_PATH' to '/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin:/tmp/ffi-0/embedding/test_thread_local'
RUNNING: ['/home/packager/aports/main/py3-cffi/src/cffi-1.17.1/.testenv/bin/python3', '/tmp/ffi-0/embedding/test_thread_local/tlocal.py'] {'cwd': '/tmp/ffi-0/embedding/test_thread_local', 'stdout': -1, 'universal_newlines': True}
generating ./_tlocal_cffi.c
the current directory is '/tmp/ffi-0/embedding/test_thread_local'
FILENAME: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so
compiling tlocal-test with ['/tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so']
----------------------------- Captured stderr call -----------------------------
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: ./_tlocal_cffi.so has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: libpython3.12.so.1.0, needed by /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so, not found (try using -rpath or -rpath-link)
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: tlocal-test: error: PHDR segment not covered by LOAD segment
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: warning: tlocal-test has a LOAD segment with RWX permissions
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyEval_EvalCode'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `_Py_NoneStruct'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `Py_IsInitialized'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyDict_SetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyErr_Display'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyErr_Fetch'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyErr_Occurred'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyGILState_Ensure'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyObject_GetAttrString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyErr_NormalizeException'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyGILState_Release'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyImport_GetModuleDict'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PySys_GetObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyFile_WriteString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyImport_ImportModule'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyDict_New'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyFile_WriteObject'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyObject_CallMethod'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyEval_SaveThread'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `_Py_Dealloc'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `Py_InitializeEx'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyLong_FromVoidPtr'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyEval_GetBuiltins'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `Py_CompileStringExFlags'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyDict_GetItemString'
/usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/../../../../x86_64-alpine-linux-musl/bin/ld: /tmp/ffi-0/embedding/test_thread_local/_tlocal_cffi.so: undefined reference to `PyCapsule_Type'
collect2: error: ld returned 1 exit status
=========================== short test summary info ============================
FAILED testing/embedding/test_basic.py::TestBasic::test_empty - distutils.com...
FAILED testing/embedding/test_basic.py::TestBasic::test_basic - distutils.com...
FAILED testing/embedding/test_basic.py::TestBasic::test_two_modules - distuti...
FAILED testing/embedding/test_basic.py::TestBasic::test_init_time_error - dis...
FAILED testing/embedding/test_basic.py::TestBasic::test_embedding_with_unicode
FAILED testing/embedding/test_performance.py::TestPerformance::test_perf_single_threaded
FAILED testing/embedding/test_performance.py::TestPerformance::test_perf_in_1_thread
FAILED testing/embedding/test_performance.py::TestPerformance::test_perf_in_2_threads
FAILED testing/embedding/test_performance.py::TestPerformance::test_perf_in_4_threads
FAILED testing/embedding/test_performance.py::TestPerformance::test_perf_in_8_threads
FAILED testing/embedding/test_recursive.py::TestRecursive::test_recursive - d...
FAILED testing/embedding/test_thread.py::TestThread::test_first_calls_in_parallel
FAILED testing/embedding/test_thread.py::TestThread::test_init_different_modules_in_different_threads
FAILED testing/embedding/test_thread.py::TestThread::test_alt_issue - distuti...
FAILED testing/embedding/test_thread.py::TestThread::test_load_in_parallel_more
FAILED testing/embedding/test_tlocal.py::TestThreadLocal::test_thread_local
= 16 failed, 1693 passed, 111 skipped, 4 xfailed, 8 warnings in 540.26s (0:09:00) =
>>> ERROR: py3-cffi: check failed
>>> py3-cffi: Uninstalling dependencies...
(1/34) Purging .makedepends-py3-cffi (20250523.163424)
(2/34) Purging py3-cparser-pyc (2.22-r1)
(3/34) Purging py3-cparser (2.22-r1)
(4/34) Purging libffi-dev (3.4.7-r0)
(5/34) Purging python3-dev (3.12.10-r1)
(6/34) Purging py3-gpep517-pyc (19-r0)
(7/34) Purging py3-gpep517 (19-r0)
(8/34) Purging py3-installer-pyc (0.7.0-r2)
(9/34) Purging py3-installer (0.7.0-r2)
(10/34) Purging py3-setuptools-pyc (80.3.1-r0)
(11/34) Purging py3-setuptools (80.3.1-r0)
(12/34) Purging py3-wheel-pyc (0.46.1-r0)
(13/34) Purging py3-wheel (0.46.1-r0)
(14/34) Purging py3-pytest-pyc (8.3.5-r0)
(15/34) Purging py3-pytest (8.3.5-r0)
(16/34) Purging py3-iniconfig-pyc (2.1.0-r0)
(17/34) Purging py3-iniconfig (2.1.0-r0)
(18/34) Purging py3-packaging-pyc (25.0-r0)
(19/34) Purging py3-packaging (25.0-r0)
(20/34) Purging py3-parsing-pyc (3.2.3-r0)
(21/34) Purging py3-parsing (3.2.3-r0)
(22/34) Purging py3-pluggy-pyc (1.5.0-r0)
(23/34) Purging py3-pluggy (1.5.0-r0)
(24/34) Purging py3-py-pyc (1.11.0-r4)
(25/34) Purging py3-py (1.11.0-r4)
(26/34) Purging python3-pyc (3.12.10-r1)
(27/34) Purging python3-pycache-pyc0 (3.12.10-r1)
(28/34) Purging pyc (3.12.10-r1)
(29/34) Purging python3 (3.12.10-r1)
(30/34) Purging gdbm (1.24-r0)
(31/34) Purging libffi (3.4.7-r0)
(32/34) Purging mpdecimal (4.0.0-r0)
(33/34) Purging sqlite-libs (3.49.2-r0)
(34/34) Purging xz-libs (5.6.3-r1)
Executing busybox-1.37.0-r12.trigger
OK: 564 MiB in 132 packages
